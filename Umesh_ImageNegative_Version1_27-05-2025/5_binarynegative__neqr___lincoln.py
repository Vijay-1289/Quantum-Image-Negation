# # -*- coding: utf-8 -*-
# """5_BinaryNegative_ NEQR _ Lincoln.ipynb

# Automatically generated by Colab.

# Original file is located at
#     https://colab.research.google.com/drive/1UF_n1WW7VYR00rgsPl9pMvLmarpBqLAM

# !pip install qiskit
# !pip install qiskit-aer
# !pip install qiskit qiskit-aer matplotlib
# !pip install pylatexenc
# !pip install qiskit qiskit-aer pillow
# !pip install qiskit-ibm-runtime
# """

import time
from PIL import Image
import numpy as np
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit_aer import AerSimulator
import matplotlib.pyplot as plt
import os

def int_to_bits(value, num_bits):
    return [int(bit) for bit in bin(value)[2:].zfill(num_bits)]

def negate_pixel(value, bits, offset=0):
    qr = QuantumRegister(bits, "q")
    cr = ClassicalRegister(bits, "c")
    qc = QuantumCircuit(qr, cr)
    binary = int_to_bits(value, bits)
    for j in range(bits):
        if binary[bits - 1 - j] == 1:
            qc.x(qr[offset + j])
    qc.barrier()
    input_circuit = qc.copy()
    for j in range(bits):
        qc.x(qr[offset + j])
    qc.barrier()
    processed_circuit = qc.copy()
    qc.measure(qr[offset:offset + bits], cr[offset:offset + bits])
    final_circuit = qc
    return input_circuit, processed_circuit, final_circuit

def create_whole_binary_image_circuit(matrix, height, width):
    N = height * width
    pos_bits = int(np.ceil(np.log2(N)))
    intensity_bits = 1
    q_pos = QuantumRegister(pos_bits, "pos")
    q_int = QuantumRegister(intensity_bits, "int")
    c_pos = ClassicalRegister(pos_bits, "c_pos")
    c_int = ClassicalRegister(intensity_bits, "c_int")
    qc = QuantumCircuit(q_pos, q_int, c_pos, c_int)
    for i in range(pos_bits):
        qc.h(q_pos[i])
    qc.barrier()
    image_flat = [matrix[r][c] for r in range(height) for c in range(width)]
    for pixel_idx in range(N):
        pos_binary = int_to_bits(pixel_idx, pos_bits)
        value = image_flat[pixel_idx]
        control_on_zero = [q_pos[j] for j, bit in enumerate(pos_binary) if bit == 0]
        for q_ctrl in control_on_zero:
            qc.x(q_ctrl)
        if value == 1:
            qc.mcx(q_pos, q_int[0])
        for q_ctrl in control_on_zero:
            qc.x(q_ctrl)
    qc.barrier()
    qc.x(q_int[0])
    qc.barrier()
    qc.measure(q_pos, c_pos)
    qc.measure(q_int, c_int)
    return qc

def negate_image_from_textfile(file_path, output_dir="output_images"):
    start_time = time.time()

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    with open(file_path, 'r') as f:
        lines = [line.strip() for line in f.readlines() if line.strip()]
    ascii_matrix = [[ord(char) for char in line] for line in lines]
    height = len(ascii_matrix)
    width = max(len(row) for row in ascii_matrix)
    for row in ascii_matrix:
        row.extend([32] * (width - len(row)))

    ascii_flat = [val for row in ascii_matrix for val in row]
    mean_val = sum(ascii_flat) / len(ascii_flat)

    binary_matrix = [[1 if val >= mean_val else 0 for val in row] for row in ascii_matrix]

    whole_image_circuit = create_whole_binary_image_circuit(binary_matrix, height, width)
    classical_matrix = [[1 - binary_matrix[r][c] for c in range(width)] for r in range(height)]
    negated_matrix = [[0 for _ in range(width)] for _ in range(height)]
    circuits = []

    for r in range(height):
        for c in range(width):
            value = binary_matrix[r][c]
            input_circuit, processed_circuit, final_circuit = negate_pixel(value, 1)
            backend = AerSimulator()
            job = backend.run(final_circuit, shots=10)
            counts = job.result().get_counts()
            bitstring = list(counts.keys())[0]
            negated_matrix[r][c] = int(bitstring, 2)
            if r == 0 and c == 0:
                circuits.append(("binary", input_circuit, processed_circuit, final_circuit))

    mse = sum((negated_matrix[r][c] - classical_matrix[r][c]) ** 2 for r in range(height) for c in range(width)) / (width * height)

    neg_img = Image.new("L", (width, height))
    for r in range(height):
        for c in range(width):
            pixel_value = 255 if negated_matrix[r][c] == 1 else 0
            neg_img.putpixel((c, r), pixel_value)

    orig_path = os.path.join(output_dir, "text_binary_original.png")
    neg_path = os.path.join(output_dir, "text_binary_negated.png")
    orig_img = Image.new("L", (width, height))
    for r in range(height):
        for c in range(width):
            orig_img.putpixel((c, r), 255 if binary_matrix[r][c] else 0)
    orig_img.save(orig_path)
    neg_img.save(neg_path)

    exec_time = time.time() - start_time

    return binary_matrix, negated_matrix, circuits, orig_img, neg_img, mse, whole_image_circuit, exec_time

if __name__ == "__main__":
    file_path = "lincon.txt"
    result = negate_image_from_textfile(file_path)
    matrix, negated_matrix, circuits, orig_img, neg_img, mse, whole_image_circuit, exec_time = result

    print("Whole Quantum Circuit for Binary Image (from text):")
    print(whole_image_circuit.draw(output="text"))

    print("Top-left 2x2 Binary Matrix Sample:")
    for row in matrix[:2]:
        print(row[:2])
    print("Top-left 2x2 Negated Matrix Sample:")
    for row in negated_matrix[:2]:
        print(row[:2])

    print(f"MSE between Quantum and Classical Negation: {mse}")
    print(f"Execution Time: {exec_time:.2f} seconds")

    if circuits:
        print("\nSample Input Circuit:")
        print(circuits[0][1].draw(output="text"))
        print("\nSample Processed Circuit:")
        print(circuits[0][2].draw(output="text"))
        print("\nSample Final Circuit:")
        print(circuits[0][3].draw(output="text"))

    plt.figure(figsize=(8, 4))
    plt.subplot(1, 2, 1)
    plt.imshow(orig_img, cmap='gray')
    plt.title("Original Binary (from Text)")
    plt.axis("off")
    plt.subplot(1, 2, 2)
    plt.imshow(neg_img, cmap='gray')
    plt.title("Quantum Negated")
    plt.axis("off")
    plt.tight_layout()
    plt.show()

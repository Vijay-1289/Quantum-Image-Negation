# # -*- coding: utf-8 -*-
# """3_BinaryNegative_FRQI_Lena_128.ipynb

# Automatically generated by Colab.

# Original file is located at
#     https://colab.research.google.com/drive/1B6-Y-J0yHWTTzPgNm89FqNH6lpDvv-vR
# """

# from PIL import Image
# img = Image.open("/content/Lenna_512.tif").convert("L").point(lambda x: 255 if x >= 128 else 0, mode="1").save("Lenna_128_binary.tiff", format="TIFF")

# import numpy as np
# from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile
# from qiskit_aer import AerSimulator
# from qiskit.quantum_info import Statevector
# from qiskit.circuit.library import RYGate
# import matplotlib.pyplot as plt
# from PIL import Image

# def hadamard(circ, qubits):
#     for i in qubits:
#         circ.h(i)

# def cnri(circ, control_qubits, target_qubit, theta):
#     controls = len(control_qubits)
#     cry = RYGate(theta).control(controls)
#     aux = np.append(control_qubits, target_qubit).tolist()
#     circ.append(cry, aux)

# def frqi_pixel_input(circ, control_qubits, target_qubit, angle, position_idx, num_qubits):
#     # Set position qubits to |position_idx>
#     bin_idx = format(position_idx, f'0{num_qubits}b')
#     for bit, qubit in enumerate(control_qubits):
#         if bin_idx[bit] == '1':
#             circ.x(qubit)
#     if angle > 0:
#         cnri(circ, control_qubits, target_qubit, angle)
#     circ.barrier()
#     circ.save_statevector(label="state_before_negation")

# def frqi_pixel_negated(circ, control_qubits, target_qubit, angle, position_idx, num_qubits):
#     frqi_pixel_input(circ, control_qubits, target_qubit, angle, position_idx, num_qubits)
#     negated_theta = np.pi/2 - angle
#     if angle > 0:
#         circ.x(target_qubit)
#     if negated_theta >= 0:
#         cnri(circ, control_qubits, target_qubit, negated_theta)
#     if angle > 0:
#         circ.x(target_qubit)
#     circ.barrier()
#     circ.save_statevector(label="state_after_negation")

# # Load image
# image_path = "/content/Lenna_128_binary.tiff"
# try:
#     img = Image.open(image_path).convert('L')
#     image = np.array(img)
#     image = (image > 128).astype(int)
# except FileNotFoundError:
#     print(f"Error: Image file {image_path} not found.")
#     exit()

# print("\nOriginal Binary Image Matrix (128x128):")
# print(image)

# n = image.shape[0]
# num_pixels = n * n
# q = int(np.ceil(np.log2(num_pixels)))  # 14 qubits
# print(f"Image size: {n}x{n}, using {q} control qubits")

# # Angles
# angles = np.pi/2 * image.flatten()

# # Classical negated image
# negated_image_classical = 1 - image
# print("\nClassical Negated Binary Image Matrix (128x128):")
# print(negated_image_classical)

# # Pixels for display
# pixels = [(image[i//n, i%n], i, (i//n, i%n)) for i in range(num_pixels)]
# display_pixels = pixels[:4]

# # Main FRQI circuit
# qr = QuantumRegister(q + 1, 'q')  # q_0 intensity, q_1 to q_14 position
# cr = ClassicalRegister(1, 'c')
# qc = QuantumCircuit(qr, cr)
# control_qubits = list(range(1, q + 1))
# target_qubit = 0

# # Superposition
# hadamard(qc, control_qubits)

# # Encode intensities
# for i in range(num_pixels):
#     if angles[i] > 0:  # Pixel 1
#         bin_idx = format(i, f'0{q}b')
#         for bit, qubit in enumerate(control_qubits):
#             if bin_idx[bit] == '1':
#                 qc.x(qubit)
#         cnri(qc, control_qubits, target_qubit, angles[i])
#         for bit, qubit in enumerate(control_qubits):  # Reset
#             if bin_idx[bit] == '1':
#                 qc.x(qubit)

# qc.barrier()

# # Negation
# for i in range(num_pixels):
#     negated_theta = np.pi/2 - angles[i]
#     if angles[i] > 0:
#         qc.x(target_qubit)
#     if negated_theta >= 0:
#         bin_idx = format(i, f'0{q}b')
#         for bit, qubit in enumerate(control_qubits):
#             if bin_idx[bit] == '1':
#                 qc.x(qubit)
#         cnri(qc, control_qubits, target_qubit, negated_theta)
#         for bit, qubit in enumerate(control_qubits):
#             if bin_idx[bit] == '1':
#                 qc.x(qubit)
#     if angles[i] > 0:
#         qc.x(target_qubit)

# qc.barrier()
# qc.measure(target_qubit, cr[0])

# # Simulate main circuit
# simulator = AerSimulator()
# shots = 10000
# transpiled = transpile(qc, simulator)
# job = simulator.run(transpiled, shots=shots)
# result = job.result()
# counts = result.get_counts()

# # Extract negated pixels
# quantum_negated_pixels = np.zeros_like(image)
# for pixel_idx in range(num_pixels):
#     bin_idx = format(pixel_idx, f'0{q}b')
#     # Simulate measurement for this position
#     pos_counts = {'0': 0, '1': 0}
#     for state, count in counts.items():
#         pos_state = state[1:] if len(state) > 1 else '0' * q
#         if pos_state == bin_idx[::-1]:  # Reverse for Qiskit ordering
#             pos_counts[state[0]] += count
#     total = pos_counts['0'] + pos_counts['1']
#     negated_pixel = 0
#     if total > 0:
#         prob_1 = pos_counts['1'] / total
#         theta_prime = 2 * np.arcsin(np.sqrt(prob_1))
#         negated_pixel = int((theta_prime / (np.pi/2)) + 0.5)
#     quantum_negated_pixels[pixel_idx // n, pixel_idx % n] = negated_pixel

# # Display circuits for four pixels
# for pixel_value, pos_idx, pos in display_pixels:
#     qr_display = QuantumRegister(q + 1, 'q')
#     cr_display = ClassicalRegister(1, 'c')
#     # Input Circuit
#     qc_input = QuantumCircuit(qr_display, cr_display)
#     frqi_pixel_input(qc_input, control_qubits, target_qubit, angles[pos_idx], pos_idx, q)
#     print(f"\nInput FRQI Circuit for Pixel {pixel_value} at Position {pos}:")
#     print(qc_input.draw(output="text"))
#     result_input = simulator.run(transpile(qc_input, simulator), shots=1).result()
#     sv_before = result_input.data().get('state_before_negation')
#     print("\nStatevector BEFORE negation:")
#     if sv_before:
#         s_vec = Statevector(sv_before)
#         for i, amp in enumerate(s_vec.data):
#             if not np.isclose(abs(amp), 0.0):
#                 pos_state = i >> 1
#                 intensity_bit = i & 1
#                 print(f"{amp:.3f} |{intensity_bit}{format(pos_state, f'0{q}b')}>")

#     # Negated Circuit
#     qc_negated = QuantumCircuit(qr_display, cr_display)
#     frqi_pixel_negated(qc_negated, control_qubits, target_qubit, angles[pos_idx], pos_idx, q)
#     qc_negated.measure(target_qubit, cr_display)
#     print(f"\nNegated FRQI Circuit for Pixel {pixel_value} at Position {pos}:")
#     print(qc_negated.draw(output="text"))
#     result_negated = simulator.run(transpile(qc_negated, simulator), shots=1).result()
#     data = result_negated.data()
#     sv_before = data.get('state_before_negation')
#     sv_after = data.get('state_after_negation')
#     print("\nStatevector BEFORE negation:")
#     if sv_before:
#         s_vec = Statevector(sv_before)
#         for i, amp in enumerate(s_vec.data):
#             if not np.isclose(abs(amp), 0.0):
#                 pos_state = i >> 1
#                 intensity_bit = i & 1
#                 print(f"{amp:.3f} |{intensity_bit}{format(pos_state, f'0{q}b')}>")
#     print("\nStatevector AFTER negation:")
#     if sv_after:
#         s_vec = Statevector(sv_after)
#         for i, amp in enumerate(s_vec.data):
#             if not np.isclose(abs(amp), 0.0):
#                 pos_state = i >> 1
#                 intensity_bit = i & 1
#                 print(f"{amp:.3f} |{intensity_bit}{format(pos_state, f'0{q}b')}>")
#     print(f"\nExpected Negated Pixel Value: {1 - pixel_value}")
#     print(f"Measured Negated Pixel Value: {quantum_negated_pixels[pos]}")

# print("\nQuantum Negated Binary Image Matrix (128x128):")
# print(quantum_negated_pixels)

# # MSE
# mse = np.mean((negated_image_classical - quantum_negated_pixels) ** 2)
# print(f"\nMean Squared Error (MSE) between Classical and Quantum Negation: {mse:.6f}")

# # Plot
# plt.figure(figsize=(8, 4))
# plt.subplot(1, 2, 1)
# plt.imshow(image, cmap='gray', vmin=0, vmax=1)
# plt.title("Original Binary Image (128x128)")
# plt.axis('off')
# plt.subplot(1, 2, 2)
# plt.imshow(quantum_negated_pixels, cmap='gray', vmin=0, vmax=1)
# plt.title("Negated Binary Image (Quantum)")
# plt.axis('off')
# plt.show()
import numpy as np
import time
from PIL import Image
import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile
from qiskit_aer import AerSimulator
from qiskit.quantum_info import Statevector
from qiskit.circuit.library import RYGate

# --- Utility functions ---
def hadamard(circ, qubits):
    for i in qubits:
        circ.h(i)

def cnri(circ, control_qubits, target_qubit, theta):
    cry = RYGate(theta).control(len(control_qubits))
    circ.append(cry, list(control_qubits) + [target_qubit])

def frqi_pixel_input(circ, control_qubits, target_qubit, angle, position_idx, num_qubits):
    bin_idx = format(position_idx, f'0{num_qubits}b')
    for bit, qubit in enumerate(control_qubits):
        if bin_idx[bit] == '1':
            circ.x(qubit)
    if angle > 0:
        cnri(circ, control_qubits, target_qubit, angle)
    circ.barrier()
    circ.save_statevector(label="state_before_negation")

def frqi_pixel_negated(circ, control_qubits, target_qubit, angle, position_idx, num_qubits):
    frqi_pixel_input(circ, control_qubits, target_qubit, angle, position_idx, num_qubits)
    negated_theta = np.pi/2 - angle
    if angle > 0:
        circ.x(target_qubit)
    if negated_theta >= 0:
        bin_idx = format(position_idx, f'0{num_qubits}b')
        for bit, qubit in enumerate(control_qubits):
            if bin_idx[bit] == '1':
                circ.x(qubit)
        cnri(circ, control_qubits, target_qubit, negated_theta)
        for bit, qubit in enumerate(control_qubits):
            if bin_idx[bit] == '1':
                circ.x(qubit)
    if angle > 0:
        circ.x(target_qubit)
    circ.barrier()
    circ.save_statevector(label="state_after_negation")

# --- Main Execution ---
start_time = time.time()

image_path = "Lenna_128_binary.tiff"
try:
    img = Image.open(image_path).convert('L')
    image = np.array(img)
    image = (image > 128).astype(int)
except FileNotFoundError:
    print(f"Error: Image file {image_path} not found.")
    exit()

print("\nOriginal Binary Image Matrix (128x128):")
print(image)

n = image.shape[0]
num_pixels = n * n
q = int(np.ceil(np.log2(num_pixels)))
angles = np.pi/2 * image.flatten()
negated_image_classical = 1 - image
print("\nClassical Negated Binary Image Matrix (128x128):")
print(negated_image_classical)

pixels = [(image[i//n, i%n], i, (i//n, i%n)) for i in range(num_pixels)]
display_pixels = pixels[:5]

# Main FRQI circuit
qr = QuantumRegister(q + 1, 'q')
cr = ClassicalRegister(1, 'c')
qc = QuantumCircuit(qr, cr)
control_qubits = list(range(1, q + 1))
target_qubit = 0

hadamard(qc, control_qubits)

for i in range(num_pixels):
    if angles[i] > 0:
        bin_idx = format(i, f'0{q}b')
        for bit, qubit in enumerate(control_qubits):
            if bin_idx[bit] == '1':
                qc.x(qubit)
        cnri(qc, control_qubits, target_qubit, angles[i])
        for bit, qubit in enumerate(control_qubits):
            if bin_idx[bit] == '1':
                qc.x(qubit)

qc.barrier()

for i in range(num_pixels):
    negated_theta = np.pi/2 - angles[i]
    if angles[i] > 0:
        qc.x(target_qubit)
    if negated_theta >= 0:
        bin_idx = format(i, f'0{q}b')
        for bit, qubit in enumerate(control_qubits):
            if bin_idx[bit] == '1':
                qc.x(qubit)
        cnri(qc, control_qubits, target_qubit, negated_theta)
        for bit, qubit in enumerate(control_qubits):
            if bin_idx[bit] == '1':
                qc.x(qubit)
    if angles[i] > 0:
        qc.x(target_qubit)

qc.barrier()
qc.measure(target_qubit, cr[0])

simulator = AerSimulator()
shots = 10
transpiled = transpile(qc, simulator)
job = simulator.run(transpiled, shots=shots)
result = job.result()
counts = result.get_counts()

quantum_negated_pixels = np.zeros_like(image)
for pixel_idx in range(num_pixels):
    bin_idx = format(pixel_idx, f'0{q}b')
    pos_counts = {'0': 0, '1': 0}
    for state, count in counts.items():
        pos_state = state[1:] if len(state) > 1 else '0' * q
        if pos_state == bin_idx[::-1]:
            pos_counts[state[0]] += count
    total = pos_counts['0'] + pos_counts['1']
    negated_pixel = 0
    if total > 0:
        prob_1 = pos_counts['1'] / total
        theta_prime = 2 * np.arcsin(np.sqrt(prob_1))
        negated_pixel = int((theta_prime / (np.pi/2)) + 0.5)
    quantum_negated_pixels[pixel_idx // n, pixel_idx % n] = negated_pixel

for pixel_value, pos_idx, pos in display_pixels:
    qr_display = QuantumRegister(q + 1, 'q')
    cr_display = ClassicalRegister(1, 'c')
    qc_input = QuantumCircuit(qr_display, cr_display)
    frqi_pixel_input(qc_input, control_qubits, target_qubit, angles[pos_idx], pos_idx, q)
    print(f"\nInput FRQI Circuit for Pixel {pixel_value} at Position {pos}:")
    print(qc_input.draw(output="text"))
    result_input = simulator.run(transpile(qc_input, simulator), shots=1).result()
    sv_before = result_input.data().get('state_before_negation')
    if sv_before:
        s_vec = Statevector(sv_before)
        print("\nStatevector BEFORE negation:")
        for i, amp in enumerate(s_vec.data):
            if not np.isclose(abs(amp), 0.0):
                pos_state = i >> 1
                intensity_bit = i & 1
                print(f"{amp:.3f} |{intensity_bit}{format(pos_state, f'0{q}b')}>")

    qc_negated = QuantumCircuit(qr_display, cr_display)
    frqi_pixel_negated(qc_negated, control_qubits, target_qubit, angles[pos_idx], pos_idx, q)
    qc_negated.measure(target_qubit, cr_display)
    print(f"\nNegated FRQI Circuit for Pixel {pixel_value} at Position {pos}:")
    print(qc_negated.draw(output="text"))
    result_negated = simulator.run(transpile(qc_negated, simulator), shots=1).result()
    data = result_negated.data()
    sv_after = data.get('state_after_negation')
    if sv_after:
        s_vec = Statevector(sv_after)
        print("\nStatevector AFTER negation:")
        for i, amp in enumerate(s_vec.data):
            if not np.isclose(abs(amp), 0.0):
                pos_state = i >> 1
                intensity_bit = i & 1
                print(f"{amp:.3f} |{intensity_bit}{format(pos_state, f'0{q}b')}>")
    print(f"\nExpected Negated Pixel Value: {1 - pixel_value}")
    print(f"Measured Negated Pixel Value: {quantum_negated_pixels[pos]}")

print("\nQuantum Negated Binary Image Matrix (128x128):")
print(quantum_negated_pixels)

mse = np.mean((negated_image_classical - quantum_negated_pixels) ** 2)
print(f"\nMean Squared Error (MSE) between Classical and Quantum Negation: {mse:.6f}")

plt.figure(figsize=(8, 4))
plt.subplot(1, 2, 1)
plt.imshow(image, cmap='gray', vmin=0, vmax=1)
plt.title("Original Binary Image (128x128)")
plt.axis('off')
plt.subplot(1, 2, 2)
plt.imshow(quantum_negated_pixels, cmap='gray', vmin=0, vmax=1)
plt.title("Negated Binary Image (Quantum)")
plt.axis('off')
plt.show()

end_time = time.time()
print(f"\n[âœ“] Total Execution Time: {end_time - start_time:.2f} seconds")



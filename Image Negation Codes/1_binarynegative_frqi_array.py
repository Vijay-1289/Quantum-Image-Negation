# # -*- coding: utf-8 -*-
# """1_BinaryNegative_FRQI_Array.ipynb

# Automatically generated by Colab.

# Original file is located at
#     https://colab.research.google.com/drive/1ZgEkNUNQ5CISeBE8dPMcaxQc8nWJIL13
# """

import numpy as np
import time
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile
from qiskit_aer import AerSimulator
from qiskit.quantum_info import Statevector
from qiskit.circuit.library import RYGate
import matplotlib.pyplot as plt

# Utility Functions
def hadamard(circ, n):
    for i in n:
        circ.h(i)

def change(state, new_state):
    return np.array([i for i in range(len(state)) if state[i] != new_state[i]])

def binary(circ, state, new_state, k):
    for i in change(state, new_state):
        circ.x(i)

def cnri(circ, control_qubits, target_qubit, theta):
    cry = RYGate(theta).control(len(control_qubits))
    circ.append(cry, list(control_qubits) + [target_qubit])

def frqi_pixel(circ, control_qubits, target_qubit, angle, position_idx, num_qubits):
    bin_idx = format(position_idx, f'0{num_qubits}b')
    for bit, qubit in enumerate(control_qubits):
        if bin_idx[bit] == '1':
            circ.x(qubit)
    if angle > 0:
        cnri(circ, control_qubits, target_qubit, angle)
    circ.barrier(label="After_Encoding")
    circ.save_statevector(label="state_before_negation")

    negated_theta = np.pi/2 - angle
    if angle > 0:
        circ.x(target_qubit)
    if negated_theta >= 0:
        cnri(circ, control_qubits, target_qubit, negated_theta)
    if angle > 0:
        circ.x(target_qubit)
    circ.barrier(label="After_Negation")
    circ.save_statevector(label="state_after_negation")

# Start timing
start_time = time.time()

# Input binary image
image = np.array([[1, 0], [1, 0]])
print("\nOriginal Image (Binary):")
print(image)

n = image.shape[0]
num_pixels = n * n
q = int(np.ceil(np.log2(num_pixels)))
angles = np.pi/2 * image.flatten()
negated_image = 1 - image

print("\nNegated Image (Binary):")
print(negated_image)

pixels = [
    (image[0,0], 0, (0,0)),
    (image[0,1], 1, (0,1)),
    (image[1,0], 2, (1,0)),
    (image[1,1], 3, (1,1))
]

shots = 999999
simulator = AerSimulator()
quantum_result = np.zeros_like(image)

for i, (pixel_value, pos_idx, pos) in enumerate(pixels):
    qr = QuantumRegister(q + 1, 'q')
    cr = ClassicalRegister(1, 'c')
    qc = QuantumCircuit(qr, cr)

    control_qubits = list(range(q))
    target_qubit = q
    angle = angles[pos_idx]

    frqi_pixel(qc, control_qubits, target_qubit, angle, pos_idx, q)
    qc.measure(target_qubit, cr)

    transpiled = transpile(qc, simulator)
    job = simulator.run(transpiled, shots=shots)
    result = job.result()

    if i < 5:
        print(f"\nFRQI Circuit for Pixel {pixel_value} at Position {pos}:")
        print(qc.draw(output="text"))

    data = result.data()
    sv_before = data.get('state_before_negation')
    sv_after = data.get('state_after_negation')

    counts = result.get_counts()
    count_1 = counts.get('1', 0)
    count_0 = counts.get('0', 0)
    total = count_0 + count_1
    negated_pixel = 0
    if total > 0:
        prob_1 = count_1 / total
        theta_prime = 2 * np.arcsin(np.sqrt(prob_1))
        negated_pixel = int((theta_prime / (np.pi/2)) + 0.5)

    quantum_result[pos] = negated_pixel

# Compute MSE
mse = np.mean((negated_image - quantum_result) ** 2)
print(f"\n[✓] MSE between classical and quantum negated images: {mse:.2f}")

# Plot and save image
plt.figure(figsize=(4, 2))
plt.imshow(quantum_result, cmap='gray', vmin=0, vmax=1)
plt.title("Negated Image (Quantum)")
plt.axis('off')
plt.savefig('negated_image_binary.png')
plt.close()

# Execution time
end_time = time.time()
print(f"\n[✓] Execution Time: {end_time - start_time:.2f} seconds")
